<!DOCTYPE html>
<html>
<head>
<title>Othello (Multiplayer)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
<style>
    #board { display: grid; grid-template-columns: repeat(8, 50px); gap: 2px; margin: 20px 0; }
    .cell { 
        width: 50px; height: 50px; 
        background-color: #2e8b57; 
        display: flex; justify-content: center; 
        align-items: center; cursor: pointer;
    }
    .stone { width: 40px; height: 40px; border-radius: 50%; border: 1px solid #333; }
    .black { background-color: #222; }
    .white { background-color: #fff; }
    .legal-move { box-shadow: inset 0 0 0 3px yellow; }
    #status { font-size: 1.2em; margin: 10px 0; }
    #game-controls { margin: 20px 0; }
    input, button { padding: 8px; margin-right: 10px; }
   
    /* AIï¼ˆã¾ãŸã¯äººé–“ï¼‰ãŒç½®ã„ãŸçŸ³ã‚’å¼·èª¿ */
    .cell.placed-move {
        box-shadow: 0 0 0 4px rgba(255,0,0,0.8);
        animation: pulse 1.8ms ease-out;
    }
    @keyframes pulse {
        0%   { box-shadow: 0 0 0 4px rgba(255,0,0,0.8); }
        100% { box-shadow: 0 0 0   rgba(255,0,0,0); }
    }
    /* çŸ³ã‚’å›è»¢ã•ã›ã‚‹ã‚³ãƒ³ãƒ†ãƒŠ */
    .cell {
    perspective: 600px;
    }

    /* å›è»¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®å®šç¾© */
    @keyframes flipStone {
    0%   { transform: rotateY(0deg); }
    50%  { transform: rotateY(90deg); }
    100% { transform: rotateY(0deg); }
    }

    /* å›è»¢ä¸­ã®çŸ³ */
    .stone.flipping {
    animation: flipStone 0.6s ease-in-out forwards;
    backface-visibility: hidden;
    transform-style: preserve-3d;
    }


</style>
</head>
<body>
<div id="game-controls">
    
    <select id="ai-level">
        <option value="3" selected>Level 3 (Easy)</option>
        <option value="4">Level 4 (Medium)</option>
        <option value="5">Level 5 (Hard)</option>
    </select>
    <button id="start-ai-game">Start vs AI</button>

    <button id="create-room">Create Room</button>
    <input id="room-id" placeholder="Room ID">
    <button id="join-room">Join Room</button>
</div>
<div id="status">Waiting to join game...</div>

<div id="score" style="font-size:1.2em; margin:10px 0;"></div>

<div id="board"></div>

<script>
    const socket = io();
    let currentGameId = null;
    let playerId = 'player-' + Math.random().toString(36).substring(2, 9);
    let yourColor = null;  // -1 ãŒé»’ã€1 ãŒç™½
    let prevLastMove = null;  // å‰å›ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆä¿æŒ
    let lastBoard = null;  // holds the previous board state
    function highlightLastMove(row, col) {
    console.log(`ğŸš€ highlightLastMove called for: (${row}, ${col})`);
    if (prevLastMove) {
        const [pr, pc] = prevLastMove;
        document.querySelector(`.cell[data-row="${pr}"][data-col="${pc}"]`)
                ?.classList.remove("last-move");
    }
    const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
    if (cell) {
        cell.classList.add("last-move");
        console.log("ğŸš€ added last-move class to cell", cell);
        prevLastMove = [row, col];
    }
    }

    // åˆæœŸåŒ–
    function initBoard() {
        const board = document.getElementById('board');
        board.innerHTML = '';
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.row = r;
                cell.dataset.col = c;
                board.appendChild(cell);
            }
        }
    }
    
    // ï¼˜æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
    const directions = [
        {dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1},
        {dx:1,dy:1},{dx:1,dy:-1},{dx:-1,dy:1},{dx:-1,dy:-1}
    ];

    // åˆæ³•æ‰‹è¨ˆç®—
    function computeLegalMoves(board, color) {
        const opponent = -color;
        const moves = [];
        for (let y = 0; y < 8; y++) {
            for (let x = 0; x < 8; x++) {
                if (board[y][x] !== 0) continue;
                for (const {dx,dy} of directions) {
                    let nx = x + dx, ny = y + dy;
                    let hasOpp = false;
                    while (0 <= nx && nx < 8 && 0 <= ny && ny < 8 && board[ny][nx] === opponent) {
                        hasOpp = true; nx += dx; ny += dy;
                    }
                    if (hasOpp && 0 <= nx && nx < 8 && 0 <= ny && ny < 8 && board[ny][nx] === color) {
                        moves.push({x, y});
                        break;
                    }
                }
            }
        }
        return moves;
    }

    // ç›¤é¢æ›´æ–°
    function updateBoard(board, turn) {
        // Clear the board first
        document.querySelectorAll('.cell').forEach(cell => {
            cell.innerHTML = '';
            cell.classList.remove('legal-move');
            cell.onclick = null;
        });

        // Draw stones
        for (let y = 0; y < 8; y++) {
            for (let x = 0; x < 8; x++) {
                const cell = document.querySelector(`.cell[data-row="${y}"][data-col="${x}"]`);
                if (board[y][x] === -1 || board[y][x] === 1) {
                    const stone = document.createElement('div');
                    stone.className = `stone ${board[y][x] === -1 ? 'black' : 'white'}`;
                    cell.appendChild(stone);
                }
            }
        }

        // Highlight legal moves if it's our turn
        if (yourColor !== null && turn === yourColor) {
            const legalMoves = computeLegalMoves(board, yourColor);
            legalMoves.forEach(move => {
                const cell = document.querySelector(`.cell[data-row="${move.y}"][data-col="${move.x}"]`);
                cell.classList.add('legal-move');
                cell.onclick = () => makeMove(move.y, move.x);
            });
        }
    }

    // æ‰‹ã‚’æ‰“ã¤
    function makeMove(row, col) {
        if (!currentGameId) {
            alert('Please join a game first!');
            return;
        }
        socket.emit('make_move', {
            game_id: currentGameId,
            player_id: playerId,
            row, col
        });
    }
        


    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
    
    // Modify the "Start vs AI" button handler
ã€€    document.getElementById('start-ai-game').addEventListener('click', () => {
        const level = parseInt(document.getElementById('ai-level').value, 10);
        const gameId = document.getElementById('room-id').value.trim();
        
        // Reset game state
        yourColor = null;
        currentGameId = null;
        
        socket.emit('start_ai_game', {
            level: level,
            game_id: gameId,
            player_id: playerId  // Send our playerId
        });
    });

    
    socket.on('joined', (data) => {
        console.log("JOINED DATA:", data);
        yourColor      = data.your_color;
        currentGameId  = data.game_id;

        initBoard();
        updateBoard(data.board, data.turn);

        document.getElementById('status').textContent =
            `You vs Opponent | Turn: ${data.turn === -1 ? 'Black' : 'White'}`;

        // ãƒ‡ãƒãƒƒã‚°
        console.log("Your color:", yourColor, "Current turn:", data.turn);
    });

        
        
        

    // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰æ–°ã—ãä½œæˆã—ãŸéƒ¨å±‹IDã‚’å—ã‘å–ã‚‹
    // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰éƒ¨å±‹ãŒä½œæˆã•ã‚ŒãŸã¨ãã®ã‚¤ãƒ™ãƒ³ãƒˆ
    socket.on('room_created', data => {
        console.log("Room created:", data.game_id);
        document.getElementById('room-id').value = data.game_id;
        currentGameId = data.game_id;  // ã“ã“ã§ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’æ›´æ–°
    });


    socket.on('game_started', data => {
        console.log("Game started event received:", data);
        // ã‚‚ã— data ã« game_id ãŒå«ã¾ã‚Œã¦ã„ã‚Œã°ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’æ›´æ–°
        if (data.game_id) {
            document.getElementById('room-id').value = data.game_id;
            currentGameId = data.game_id;
        }
        updateBoard(data.board);  // ç›¤é¢æç”»é–¢æ•°ã‚’å‘¼ã¶
        document.getElementById('status').textContent =
            `Turn: ${data.turn === -1 ? 'Black' : 'White'}`;
    });




    document.getElementById('create-room').addEventListener('click', () => {
        fetch('/create_room')
            .then(res => res.json())
            .then(data => {
                currentGameId = data.game_id;
                document.getElementById('room-id').value = data.game_id;
                socket.emit('join_game', {
                    game_id: data.game_id,
                    player_id: playerId,
                    name: 'Player-' + playerId.substring(7)
                });
                document.getElementById('status').textContent = 'Room created. Waiting for opponent...';
            });
    });

    document.getElementById('join-room').addEventListener('click', () => {
        const roomId = document.getElementById('room-id').value.trim();
        if (!roomId) return alert('Please enter a Room ID');
        currentGameId = roomId;
        socket.emit('join_game', {
            game_id: roomId,
            player_id: playerId,
            name: 'Player-' + playerId.substring(7)
        });
        document.getElementById('status').textContent = 'Joining game...';
    });

    /// Update the 'joined' event handler
        socket.on('joined', (data) => {
            console.log("JOINED:", data);
            yourColor = data.your_color;  // This should be -1 for human in AI mode
            
            const me = data.players.find(p => p.id === playerId);
            const opp = data.players.find(p => p.id !== playerId);
            
            const meName = me ? me.name : 'You';
            const oppName = opp ? opp.name : 'Waiting...';
            const meColor = yourColor === -1 ? 'Black' : 'White';
            
            document.getElementById('status').textContent =
                `${meName} (${meColor}) vs ${oppName} | Turn: ${data.turn === -1 ? 'Black' : 'White'}`;
            
            initBoard();
            updateBoard(data.board, data.turn);
            
            // Debug output
            console.log("Your color:", yourColor, "Current turn:", data.turn);
            console.log("Legal moves:", computeLegalMoves(data.board, yourColor));
        });

        // Update the 'game_state' handler
        

        // AIè€ƒãˆä¸­ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’å‡¦ç†
socket.on('ai_thinking', () => {
    console.log("AI is thinking...");
    // å¿…è¦ãªã‚‰ã“ã“ã«AIè€ƒãˆä¸­ã®è¡¨ç¤ºã‚’å…¥ã‚Œã‚‹ã“ã¨ã‚‚å¯èƒ½
});

socket.on('game_state', data => {
  console.log('ğŸ’¡ game_state:', data);

  const newBoard = data.board;
  const turn     = data.turn;
  const isPlayerMove = data.player_move === true;
  const isAIMove      = data.ai_move === true;

  // 1. ã²ã£ãã‚Šè¿”ã™çŸ³ã‚’ç‰¹å®š
  const flips = [];
  if (lastBoard) {
    for (let y = 0; y < 8; y++) {
      for (let x = 0; x < 8; x++) {
        const oldC = lastBoard[y][x];
        const newC = newBoard[y][x];
        if (oldC !== 0 && oldC !== newC) {
          flips.push({ y, x, to: newC });
        }
      }
    }
  }

  // 2. æœ€å¾Œã«æ‰“ã£ãŸæ‰‹ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
  if (data.last_move) {
    highlightLastMove(data.last_move[0], data.last_move[1]);
    // 2) â€œç½®ã‹ã‚ŒãŸâ€ çŸ³ã‚’èµ¤ãå¼·èª¿ã™ã‚‹
  
    const [pr, pc] = data.last_move;
    const placedCell = document.querySelector(
      `.cell[data-row="${pr}"][data-col="${pc}"]`
    );
    if (placedCell) {
      placedCell.classList.add('placed-move');
      // 800ms ã§å¼·èª¿ã‚’æ¶ˆã™
      setTimeout(() => {
        placedCell.classList.remove('placed-move');
      }, 800);
    }
  }

  // 3. æ–°ã—ã„ç›¤é¢ã‚’æç”»
  updateBoard(newBoard.map(r => r.slice()), turn);

  // 4. å„ã²ã£ãã‚Šè¿”ã—ã‚’ 3D ã§å›è»¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
  flips.forEach(({y, x, to}, i) => {
      setTimeout(() => {
        const cell = document.querySelector(`.cell[data-row="${y}"][data-col="${x}"]`);
        if (!cell) return;
        // â‘  æ—¢å­˜ã®çŸ³è¦ç´ ã‚’å–å¾—
        const stone = cell.querySelector('.stone');
        if (!stone) return;
        // â‘¡ flipping ã‚¯ãƒ©ã‚¹ã§ 3D å›è»¢é–‹å§‹
        stone.classList.add('flipping');
        // â‘¢ å›è»¢ã®ä¸­é–“ã§è‰²ã‚’åˆ‡ã‚Šæ›¿ãˆ
        setTimeout(() => {
          stone.classList.remove('black', 'white');
          stone.classList.add(to===-1 ? 'black' : 'white');
        }, 300); // flipStone ã‚¢ãƒ‹ãƒ¡ã®åŠåˆ† (0.6s ã®åŠåˆ†)
        // â‘£ ã‚¢ãƒ‹ãƒ¡å®Œäº†å¾Œã«ã‚¯ãƒ©ã‚¹ã‚’å¤–ã™
        setTimeout(() => {
          stone.classList.remove('flipping');
        }, 600);
      }, i * 200);  // çŸ³ã”ã¨ã« 200ms é–“éš”ã§ã‚¹ã‚¿ãƒ¼ãƒˆ
    });

  const animationDelay = flips.length * 200 + 100;

  // 5. ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†å¾Œã«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ï¼åˆæ³•æ‰‹ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’æ›´æ–°
  setTimeout(() => {
    // AI ã®æ‰‹ã®ã‚ã¨ã ã‘é…å»¶æ¼”å‡º
    if (isAIMove) {
      // a) ã€ŒAI is movingâ€¦ã€ã‚’ä¸€æ—¦è¡¨ç¤º
      document.getElementById('status').textContent = 'AI is movingâ€¦';
      // b) ã•ã‚‰ã« 500ms é…ã‚‰ã›ã¦æœ¬æ¥ã®è¡¨ç¤ºï¼†åˆæ³•æ‰‹ãƒã‚¤ãƒ©ã‚¤ãƒˆ
      setTimeout(() => {
        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
        if (data.status === 'game_over') {
          document.getElementById('status').textContent =
            `Game Over â€” W:${data.score.white} B:${data.score.black}`;
        } else {
          const turnText = turn === -1 ? 'Black' : 'White';
          let txt = `Turn: ${turnText}`;
          if (turn === yourColor) txt += ' (Your move)';
          document.getElementById('status').textContent = txt;
        }
        // åˆæ³•æ‰‹ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        document.querySelectorAll('.cell.legal-move')
          .forEach(c => c.classList.remove('legal-move'));
        if (turn === yourColor) {
          computeLegalMoves(newBoard, yourColor).forEach(m => {
            const c = document.querySelector(
              `.cell[data-row="${m.y}"][data-col="${m.x}"]`
            );
            c.classList.add('legal-move');
            c.onclick = () => makeMove(m.y, m.x);
          });
        }
        // ã‚¹ã‚³ã‚¢æ›´æ–°ï¼ˆã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã®ã¿ï¼‰
        const scoreEl = document.getElementById('score');
        scoreEl.textContent = data.status === 'game_over'
          ? `Final Score â€” W:${data.score.white} B:${data.score.black}`
          : '';
        // æ¬¡å› diff ã®ãŸã‚ã«ç›¤é¢ä¿å­˜
        lastBoard = newBoard.map(r => r.slice());
      }, 500);
    } else {
      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ‰‹ã‚„åˆå›è¡¨ç¤ºãªã©ã¯å³æ™‚è¡¨ç¤º
      if (data.status === 'game_over') {
        document.getElementById('status').textContent =
          `Game Over â€” W:${data.score.white} B:${data.score.black}`;
      } else {
        const turnText = turn === -1 ? 'Black' : 'White';
        let txt = `Turn: ${turnText}`;
        if (turn === yourColor) txt += ' (Your move)';
        document.getElementById('status').textContent = txt;
      }
      // åˆæ³•æ‰‹ãƒã‚¤ãƒ©ã‚¤ãƒˆ
      document.querySelectorAll('.cell.legal-move')
        .forEach(c => c.classList.remove('legal-move'));
      if (turn === yourColor) {
        computeLegalMoves(newBoard, yourColor).forEach(m => {
          const c = document.querySelector(
            `.cell[data-row="${m.y}"][data-col="${m.x}"]`
          );
          c.classList.add('legal-move');
          c.onclick = () => makeMove(m.y, m.x);
        });
      }
      // ã‚¹ã‚³ã‚¢æ›´æ–°ï¼ˆã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã®ã¿ï¼‰
      const scoreEl = document.getElementById('score');
      scoreEl.textContent = data.status === 'game_over'
        ? `Final Score â€” W:${data.score.white} B:${data.score.black}`
        : '';
      // æ¬¡å› diff ã®ãŸã‚ã«ç›¤é¢ä¿å­˜
      lastBoard = newBoard.map(r => r.slice());
    }
  }, animationDelay);
}); 


        

    // åˆæœŸæç”»
    initBoard();
</script>
</body>
</html>
