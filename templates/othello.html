<!DOCTYPE html>
<html>
<head>
  <title>Othello (Multiplayer)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
  <style>
    /* --- 基本スタイル --- */
    #board { display: grid; grid-template-columns: repeat(8, 50px); gap: 2px; margin: 20px 0; }
    .cell {
      width: 50px; height: 50px;
      background-color: #2e8b57;
      display: flex; justify-content: center; align-items: center;
      cursor: pointer;
      perspective: 600px; /* 3D フリップ用 */
    }
    .stone { width: 40px; height: 40px; border-radius: 50%; border: 1px solid #333; }
    .black { background-color: #222; }
    .white { background-color: #fff; }
    #status, #score { font-size: 1.2em; margin: 10px 0; }
    #game-controls { margin: 20px 0; }
    input, button, select { padding: 8px; margin-right: 10px; }

    /* --- 置かれた石の強調 --- */
    .cell.placed-move {
      box-shadow: 0 0 0 4px rgba(255,0,0,0.8);
      animation: pulse 0.8s ease-out;
    }
    @keyframes pulse {
      0%   { box-shadow: 0 0 0 4px rgba(255,0,0,0.8); }
      100% { box-shadow: 0 0 0   rgba(255,0,0,0); }
    }

    /* --- ひっくり返しアニメ --- */
    @keyframes flipStone {
      0%   { transform: rotateY(0deg); }
      50%  { transform: rotateY(90deg); }
      100% { transform: rotateY(0deg); }
    }
    .stone.flipping {
      animation: flipStone 0.6s ease-in-out forwards;
      backface-visibility: hidden;
      transform-style: preserve-3d;
    }
  </style>
</head>
<body>
  <div id="game-controls">
    <select id="ai-level">
      <option value="3" selected>Level 3 (Easy)</option>
      <option value="4">Level 4 (Medium)</option>
      <option value="5">Level 5 (Hard)</option>
    </select>
    <button id="start-ai-game">Start vs AI</button>
    <button id="create-room">Create Room</button>
    <input id="room-id" placeholder="Room ID">
    <button id="join-room">Join Room</button>
  </div>

  <div id="status">Waiting to join game...</div>
  <div id="score"></div>
  <div id="board"></div>

  <script>
  //─────────────────────────────────────────
  // 1. グローバル変数／初期化
  //─────────────────────────────────────────
  const socket    = io();
  let currentGameId = null;
  let playerId      = 'player-' + Math.random().toString(36).slice(2,9);
  let yourColor     = null;     // -1=Black, +1=White
  let prevLastMove  = null;     // [row, col]
  let lastBoard     = null;     // 前回盤面(2D配列)
  const directions  = [
    {dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1},
    {dx:1,dy:1},{dx:1,dy:-1},{dx:-1,dy:1},{dx:-1,dy:-1}
  ];

  function initBoard() {
    const board = document.getElementById('board');
    board.innerHTML = '';
    for (let r=0; r<8; r++) {
      for (let c=0; c<8; c++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.row = r;
        cell.dataset.col = c;
        board.appendChild(cell);
      }
    }
  }

  //─────────────────────────────────────────
  // 2. ユーティリティ関数
  //─────────────────────────────────────────
  function computeLegalMoves(board, color) {
    const opponent = -color, moves = [];
    for (let y=0; y<8; y++) {
      for (let x=0; x<8; x++) {
        if (board[y][x]!==0) continue;
        for (const {dx,dy} of directions) {
          let nx=x+dx, ny=y+dy, hasOpp=false;
          while (ny>=0 && ny<8 && nx>=0 && nx<8 && board[ny][nx]===opponent) {
            hasOpp = true; nx+=dx; ny+=dy;
          }
          if (hasOpp && ny>=0 && ny<8 && nx>=0 && nx<8 && board[ny][nx]===color) {
            moves.push({y,x}); break;
          }
        }
      }
    }
    return moves;
  }

  function highlightLastMove(r, c) {
    if (prevLastMove) {
      const [pr,pc] = prevLastMove;
      document.querySelector(`.cell[data-row="${pr}"][data-col="${pc}"]`)
              ?.classList.remove('last-move');
    }
    const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
    if (cell) {
      cell.classList.add('last-move');
      prevLastMove = [r,c];
    }
  }

  function updateBoard(board, turn) {
    // Clear
    document.querySelectorAll('.cell').forEach(cell=>{
      cell.innerHTML=''; cell.onclick=null;
    });
    // Draw stones
    for (let y=0; y<8; y++) {
      for (let x=0; x<8; x++) {
        const v = board[y][x];
        if (v===-1 || v===1) {
          const cell = document.querySelector(`.cell[data-row="${y}"][data-col="${x}"]`);
          const stone = document.createElement('div');
          stone.className = `stone ${v===-1?'black':'white'}`;
          cell.appendChild(stone);
        }
      }
    }
    // Legal moves (only your turn)
    if (yourColor!==null && turn===yourColor) {
      computeLegalMoves(board,yourColor).forEach(({y,x})=>{
        const cell = document.querySelector(`.cell[data-row="${y}"][data-col="${x}"]`);
        cell.onclick = ()=> makeMove(y,x);
      });
    }
  }

  function makeMove(r,c) {
    if (!currentGameId) { alert('Please join a game first!'); return; }
    socket.emit('make_move', {
      game_id: currentGameId,
      player_id: playerId,
      row: r, col: c
    });
  }

  function animateFlips(newBoard, flips) {
    // flips: [{y,x,to}]
    flips.forEach(({y,x,to}, i) => {
      setTimeout(()=>{
        const cell = document.querySelector(`.cell[data-row="${y}"][data-col="${x}"]`);
        const stone = cell.querySelector('.stone');
        if (!stone) return;
        stone.classList.add('flipping');
        // 半回転後に色を変える
        setTimeout(()=>{
          stone.classList.remove('black','white');
          stone.classList.add(to===-1?'black':'white');
        }, 300);
        // アニメ完了
        setTimeout(()=>stone.classList.remove('flipping'), 600);
      }, i*300);
    });
    return flips.length*200 + 100; // 総アニメ時間 + バッファ
  }

  function updateStatusAndHighlight(data, turn) {
    // Turn 表示
    let txt;
    if (data.status==='game_over') {
      txt = `Game Over — W:${data.score.white} B:${data.score.black}`;
    } else {
      const t = turn===-1?'Black':'White';
      txt = `Turn: ${t}` + (turn===yourColor?' (Your move)':'');
    }
    document.getElementById('status').textContent = txt;
    // Score
    document.getElementById('score').textContent =
      data.status==='game_over'
        ? `Final Score — W:${data.score.white} B:${data.score.black}`
        : '';
    // Legal moves
    if (data.status!=='game_over' && turn===yourColor) {
      computeLegalMoves(data.board,yourColor).forEach(({y,x})=>{
        const cell = document.querySelector(`.cell[data-row="${y}"][data-col="${x}"]`);
        cell.onclick = ()=> makeMove(y,x);
      });
    }
  }

  //─────────────────────────────────────────
  // 3. Socket.IO イベントハンドラ
  //─────────────────────────────────────────
  socket.on('connect', () => {      
    playerId = socket.id;           // ← 接続時にIDをセット
    console.log('My playerId:', playerId);
 });

  socket.on('room_created', data => {
    currentGameId = data.game_id;
    document.getElementById('room-id').value = data.game_id;
  });

  socket.on('joined', data => {
    yourColor     = data.your_color;
    currentGameId = data.game_id;
    initBoard();
    updateBoard(data.board,data.turn);
    document.getElementById('status').textContent =
      `Turn: ${data.turn===-1?'Black':'White'}`;
    lastBoard = data.board.map(r=>r.slice());
  });

  socket.on('game_started', data => {
    currentGameId = data.game_id || currentGameId;
    initBoard();
    updateBoard(data.board,data.turn);
    document.getElementById('status').textContent =
      `Turn: ${data.turn===-1?'Black':'White'}`;
    lastBoard = data.board.map(r=>r.slice());
  });

  socket.on('ai_thinking', ()=> {
    document.getElementById('status').textContent = 'AI is thinking…';
  });

  socket.on('game_state', data => {
    const newBoard = data.board, turn = data.turn;
    // 1) ひっくり返しリスト作成
    const flips = [];
    if (lastBoard) {
      for (let y=0; y<8; y++){
        for (let x=0; x<8; x++){
          const o=lastBoard[y][x], n=newBoard[y][x];
          if (o!==0 && o!==n) flips.push({y,x,to:n});
        }
      }
    }
    // 2) 置かれた手を強調
    if (data.last_move) {
      const [r,c]=data.last_move;
      highlightLastMove(r,c);
      const placed = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
      if (placed) {
        placed.classList.add('placed-move');
        setTimeout(()=>placed.classList.remove('placed-move'),800);
      }
    }
    // 3) 直ちに再描画
    updateBoard(newBoard.map(r=>r.slice()), turn);
    // 4) ひっくり返しアニメ
    const delay = animateFlips(newBoard, flips);
    // 5) アニメ後にステータス更新・合法手
    setTimeout(()=> {
      updateStatusAndHighlight(data, turn);
      lastBoard = newBoard.map(r=>r.slice());
    }, delay);
  });

  //─────────────────────────────────────────
  // 4. UI ボタンイベント
  //─────────────────────────────────────────

  document.getElementById('start-ai-game')
    .addEventListener('click', () => {
      const level  = +document.getElementById('ai-level').value;
      const gameId = document.getElementById('room-id').value.trim();
      yourColor = null;
      socket.emit('start_ai_game', { level, game_id:gameId, player_id:playerId });
    });

    

   document.getElementById('create-room')
    .addEventListener('click', () => {
      fetch('/create_room')
        .then(res => res.json())
        .then(data => {
          const gid = data.game_id;
          // ① 取得したIDをグローバル変数に保持
          currentGameId = gid;
          // ② 入力欄に表示
          document.getElementById('room-id').value = gid;
          // ③ ステータスにも表示（任意）
          document.getElementById('status').textContent = `Created Room: ${gid}`;

         
        })
        .catch(err => {
          console.error('Failed to create room:', err);
          document.getElementById('status').textContent = 'Error creating room';
         });
    });



  document.getElementById('join-room')
    .addEventListener('click', () => {
      const rid = document.getElementById('room-id').value.trim();
      if (!rid) return alert('Please enter a Room ID');
      socket.emit('join_game',{ game_id:rid, player_id: playerId, name:'Player-'+playerId.slice(-4) });
    });

  //─────────────────────────────────────────
  // 5. 初期描画
  //─────────────────────────────────────────
  initBoard();
  </script>
</body>
</html>
