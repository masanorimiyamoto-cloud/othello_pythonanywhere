<!DOCTYPE html>
<html>
<head>
  <title>Othello (Multiplayer)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
  <style>
    /* --- 基本スタイル --- */
    #board { display: grid; grid-template-columns: repeat(8, 50px); gap: 2px; margin: 20px 0; }
    .cell {
      width: 50px; height: 50px;
      background-color: #2e8b57;
      display: flex; justify-content: center; align-items: center;
      cursor: pointer;
      perspective: 600px; /* 3D フリップ用 */
    }
    .stone { width: 40px; height: 40px; border-radius: 50%; border: 1px solid #333; }
    .black { background-color: #222; }
    .white { background-color: #fff; }
    #status, #score { font-size: 1.2em; margin: 10px 0; }
    #game-controls { margin: 20px 0; }
    input, button, select { padding: 8px; margin-right: 10px; }

    /* --- 置かれた石の強調 --- */
    .cell.placed-move {
      box-shadow: 0 0 0 4px rgba(255,0,0,0.8);
      animation: pulse 0.8s ease-out;
    }
    @keyframes pulse {
      0%   { box-shadow: 0 0 0 4px rgba(255,0,0,0.8); }
      100% { box-shadow: 0 0 0   rgba(255,0,0,0); }
    }

    /* --- フリップアニメ CSS --- */
    .stone {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      backface-visibility: hidden;
      transform-style: preserve-3d;
    }
    .stone.flipping {
      animation: flipBlackToWhite 0.6s ease-in-out forwards;
    }
    .stone.flipping.reverse {
      animation: flipWhiteToBlack 0.6s ease-in-out forwards;
    }
    @keyframes flipBlackToWhite {
      0%   { transform: rotateY(0deg);   background-color: #222; }
      50%  { transform: rotateY(90deg);  background-color: #666; }
      100% { transform: rotateY(180deg); background-color: #fff; }
    }
    @keyframes flipWhiteToBlack {
      0%   { transform: rotateY(0deg);   background-color: #fff; }
      50%  { transform: rotateY(90deg);  background-color: #666; }
      100% { transform: rotateY(180deg); background-color: #222; }
    }
  </style>
</head>
<body>
  <div id="game-controls">
    <select id="ai-level">
      <option value="1" selected>Level 1 (Easy)</option>
      <option value="2">Level 2</option>
      <option value="3">Level 3</option>
      <option value="4">Level 4</option>
      <option value="5">Level 5 (Expert)</option>
    </select>
    <button id="start-ai-game">Start vs AI</button>
    <button id="create-room">Create Room</button>
    <input id="room-id" placeholder="Room ID">
    <button id="join-room">Join Room</button>
  </div>

  <div id="status">Waiting to join game...</div>
  <div id="score"></div>
  <div id="board"></div>

  {% raw %}
  <script>
    // 1. グローバル変数
    let isAIGame      = false;
    const socket      = io();
    let playerId      = null;
    let currentGameId = null;
    let yourColor     = null;
    let prevLastMove  = null;
    let lastBoard     = null;
    const directions  = [
      {dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1},
      {dx:1,dy:1},{dx:1,dy:-1},{dx:-1,dy:1},{dx:-1,dy:-1}
    ];

    socket.on('connect', () => {
      playerId = socket.id;
    });

    // 2. ボタンイベント
    document.getElementById('create-room')
      .addEventListener('click', () => {
        socket.emit('create_room', { player_id: playerId });
      });

    document.getElementById('join-room')
      .addEventListener('click', () => {
        const rid = document.getElementById('room-id').value.trim();
        if (!rid) return alert('Please enter a Room ID');
        isAIGame  = false;
        yourColor = null;
        socket.emit('join_game', {
          game_id:   rid,
          player_id: playerId,
          name:      'Player-' + playerId.slice(-4)
        });
      });

    document.getElementById('start-ai-game')
      .addEventListener('click', () => {
        const level = +document.getElementById('ai-level').value;
        const rid   = document.getElementById('room-id').value.trim() || null;
        isAIGame  = true;
        yourColor = -1;
        socket.emit('start_ai_game', {
          level,
          game_id:   rid,
          player_id: playerId
        });
      });

    // 3. 盤面初期化
    function initBoard() {
      const board = document.getElementById('board');
      board.innerHTML = '';
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.row = r;
          cell.dataset.col = c;
          board.appendChild(cell);
        }
      }
    }

    // 4. 合法手計算
    function computeLegalMoves(board, color) {
      const opponent = -color, moves = [];
      for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
          if (board[y][x] !== 0) continue;
          for (const {dx,dy} of directions) {
            let nx = x+dx, ny = y+dy, hasOpp = false;
            while (ny>=0 && ny<8 && nx>=0 && nx<8 && board[ny][nx]===opponent) {
              hasOpp = true; nx+=dx; ny+=dy;
            }
            if (hasOpp && ny>=0 && ny<8 && nx>=0 && nx<8 && board[ny][nx]===color) {
              moves.push({y,x}); break;
            }
          }
        }
      }
      return moves;
    }

    // 5. 最後に置かれた手強調
    function highlightLastMove(r, c) {
      if (prevLastMove) {
        const [pr,pc] = prevLastMove;
        document.querySelector(`.cell[data-row="${pr}"][data-col="${pc}"]`)
                ?.classList.remove('last-move');
      }
      const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
      if (cell) {
        cell.classList.add('last-move');
        prevLastMove = [r,c];
      }
    }

    // 6. 盤面描画
    function updateBoard(board, turn) {
      document.querySelectorAll('.cell').forEach(cell=>{
        cell.innerHTML = '';
        cell.onclick = null;
      });
      for (let y=0; y<8; y++){
        for (let x=0; x<8; x++){
          const v = board[y][x];
          if (v===-1||v===1){
            const cell = document.querySelector(`.cell[data-row="${y}"][data-col="${x}"]`);
            const stone = document.createElement('div');
            stone.className = `stone ${v===-1?'black':'white'}`;
            cell.appendChild(stone);
          }
        }
      }
      if (yourColor!==null && turn===yourColor){
        computeLegalMoves(board,yourColor).forEach(({y,x})=>{
          document.querySelector(`.cell[data-row="${y}"][data-col="${x}"]`)
                  .onclick = ()=> makeMove(y,x);
        });
      }
    }

    // 7. プレイヤー手送信
    function makeMove(r,c){
      if (!currentGameId)   return alert('Please join a game first!');
      if (yourColor===null) return alert('Please wait for the game to start!');
      socket.emit('make_move',{
        game_id:   currentGameId,
        player_id: playerId,
        row:        r,
        col:        c
      });
    }

    // 8. フリップアニメ
    function animateFlips(flips){
      const perDelay = 200, duration = 600;
      flips.forEach(({y,x},i)=>{
        setTimeout(()=>{
          const cell  = document.querySelector(`.cell[data-row="${y}"][data-col="${x}"]`);
          const stone = cell?.querySelector('.stone');
          if (!stone) return;
          const isBlack = stone.classList.contains('black');
          stone.classList.add('flipping');
          stone.classList.toggle('reverse', isBlack);
          setTimeout(()=>{
            stone.classList.remove('flipping','reverse');
            stone.classList.toggle('black');
            stone.classList.toggle('white');
          }, duration);
        }, i*perDelay);
      });
      return flips.length*perDelay + duration;
    }

    // 9. ステータス更新
    function updateStatusAndHighlight(data, turn){
      let txt;
      if (data.status==='game_over'){
        txt = `Game Over — W:${data.score.white} B:${data.score.black}`;
      } else {
        const t = turn===-1?'Black':'White';
        txt = `Turn: ${t}` + (turn===yourColor?' (Your move)':'');
      }
      document.getElementById('status').textContent = txt;
      document.getElementById('score').textContent =
        data.status==='game_over'
          ? `Final Score — W:${data.score.white} B:${data.score.black}`
          : '';
    }

    // 10. ゲームオーバー画面
    function showGameOverScreen(score){
      const ex = document.getElementById('game-over-overlay');
      if (ex) ex.remove();
      const overlay = document.createElement('div');
      overlay.id = 'game-over-overlay';
      Object.assign(overlay.style, {
        position:'fixed',top:0,left:0,width:'100%',height:'100%',
        backgroundColor:'rgba(0,0,0,0.7)',display:'flex',
        alignItems:'center',justifyContent:'center',zIndex:1000
      });
      const box = document.createElement('div');
      Object.assign(box.style, {
        backgroundColor:'#fff',padding:'24px',
        borderRadius:'8px',textAlign:'center',minWidth:'300px'
      });
      box.innerHTML = `
        <h2>Game Over</h2>
        <p>White: ${score.white} — Black: ${score.black}</p>
        <button id="restart-btn">Play Again</button>
      `;
      overlay.appendChild(box);
      document.body.appendChild(overlay);
      document.getElementById('restart-btn')
        .addEventListener('click', ()=> location.reload());
    }

    // 11. ソケットイベント
    socket.on('room_created', data=>{
      currentGameId = data.game_id;
      document.getElementById('room-id').value = data.game_id;
      document.getElementById('status').textContent =
        `Room created: ${data.game_id}. Waiting…`;
    });

    socket.on('joined', data=>{
      currentGameId = data.game_id;
      yourColor     = data.your_color;
      isAIGame      = data.players.some(p=>p.id==='AI');
      initBoard();
      updateBoard(data.board, data.turn);
      lastBoard = data.board.map(r=>r.slice());
      updateStatusAndHighlight(data, data.turn);
    });

    socket.on('game_started', data=>{
      isAIGame      = false;
      currentGameId = data.game_id;
      initBoard();
      updateBoard(data.board, data.turn);
      lastBoard = data.board.map(r=>r.slice());
      updateStatusAndHighlight(data, data.turn);
    });

      // ──────────────────────────────────────────
    // human の一手が確定したら来るイベント
    // ──────────────────────────────────────────
    socket.on('game_state', data => {
      // ──────────────────────────────────────────
      // 1) もし game_over なら、即オーバーレイ表示して戻る
      if (data.status === 'game_over') {
        updateBoard(data.board, null);
        showGameOverScreen(data.score);
        lastBoard = data.board.map(r=>r.slice());
        return;
      }

      const newBoard = data.board;

      // ──────────────────────────────────────────
      // 2) 返る石を抽出 → “置かれた一手”を先に描画 → フリップアニメ
      const flips = [];
      if (lastBoard) {
        for (let y = 0; y < 8; y++) {
          for (let x = 0; x < 8; x++) {
            if (lastBoard[y][x] !== 0 && lastBoard[y][x] !== newBoard[y][x]) {
              flips.push({ y, x });
            }
          }
        }
      }

      if (Array.isArray(data.last_move)) {
        const [r, c] = data.last_move;
        highlightLastMove(r, c);
        const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
        if (cell) {
          cell.innerHTML = '';
          const v = newBoard[r][c];
          const stone = document.createElement('div');
          stone.className = `stone ${v===-1?'black':'white'} placed-move`;
          cell.appendChild(stone);
          setTimeout(() => stone.classList.remove('placed-move'), 800);
        }
      }

      const delay = animateFlips(flips);

      // ──────────────────────────────────────────
      // 3) アニメ後に盤面全体を再描画 & ターン表示
      // ──────────────────────────────────────────
      setTimeout(() => {
        updateBoard(newBoard, data.turn);


        // まず常に本来のターンを表示＆合法手設定
      updateStatusAndHighlight(data, data.turn);
        // ただし、本当にAI（白）の番ならステータスだけ上書き
        if (isAIGame && data.turn === 1) {
          document.getElementById('status').textContent = 'AI is thinking…';
        }

        lastBoard = newBoard.map(row => row.slice());
      }, delay);
    });


    socket.on('ai_thinking', ()=>{
      if (!isAIGame) return;
      document.getElementById('status').textContent = 'AI is thinking…';
    });

    socket.on('ai_move', data => {
      if (!isAIGame) return;

      // 1) 新しく置かれた石を描画
      if (data.new_stone) {
        const { y, x } = data.new_stone;
        const cell  = document.querySelector(`.cell[data-row="${y}"][data-col="${x}"]`);
        const stone = document.createElement('div');
        stone.className = 'stone white placed-move';
        cell.appendChild(stone);
        setTimeout(() => stone.classList.remove('placed-move'), 800);
      }

      // 2) 反転アニメーション
      const flips = data.flips || [];
      const delay = animateFlips(flips);

      // 3) アニメ後に盤面更新とステータス表示
      setTimeout(() => {
        updateBoard(data.board, data.turn);
        updateStatusAndHighlight(data, data.turn);
        lastBoard = data.board.map(row => row.slice());

        // 4) もしゲ
        // ーム終了ならオーバーレイ表示
        if (data.status === 'game_over') {
          showGameOverScreen(data.score);
        }
      }, delay);
    });

    // 12. 初期描画
    initBoard();
  </script>
  {% endraw %}
</body>
</html>
<!-- End of Othello HTML Template -->